<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI ì±—ë´‡ í…ŒìŠ¤íŠ¸ (ë³´ê³ ì„œ ê¸°ë°˜)</title>
    <!-- Tailwind CSS (for quick styling) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Marked.js (for markdown rendering) -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        .markdown-body {
            font-size: 14px;
            line-height: 1.6;
        }

        .markdown-body h1,
        .markdown-body h2,
        .markdown-body h3 {
            font-weight: 600;
            margin-top: 1em;
            margin-bottom: 0.5em;
        }

        .markdown-body p {
            margin-bottom: 0.5em;
        }

        .markdown-body ul {
            list-style-type: disc;
            padding-left: 1.5em;
            margin-bottom: 0.5em;
        }

        .markdown-body strong {
            font-weight: bold;
        }
    </style>
</head>

<body class="bg-gray-100 h-screen flex flex-col items-center justify-center p-4">

    <div class="w-full max-w-3xl bg-white rounded-xl shadow-lg border border-gray-200 overflow-hidden flex flex-col"
        style="height: 90vh;">
        <!-- Header -->
        <div class="bg-blue-600 text-white px-6 py-4 flex justify-between items-center shadow-md">
            <div>
                <h1 class="text-xl font-bold">MOLIP AI ì±—ë´‡ ğŸ§ª</h1>
                <p class="text-sm text-blue-100" id="header-info">ì—°ê²° ì¤€ë¹„ ì¤‘...</p>
            </div>
        </div>

        <!-- Chat Flow (Scrollable) -->
        <div id="chat-box" class="flex-1 overflow-y-auto p-6 space-y-6 bg-gray-50">
            <!-- Messages will be injected here -->
        </div>

        <!-- Loading Indicator -->
        <div id="loading" class="hidden text-center text-gray-400 text-sm py-2">
            AIê°€ ì‘ë‹µì„ ìƒì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤...
        </div>

        <!-- Input Area -->
        <div class="border-t border-gray-200 bg-white p-4 pb-6 flex gap-2">
            <input type="text" id="user-input"
                class="flex-1 px-4 py-3 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                placeholder="ì§ˆë¬¸ì„ ì…ë ¥í•˜ì„¸ìš”... (Enter í‚¤ë¡œ ì „ì†¡)" disabled>
            <button id="send-btn"
                class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-lg font-semibold transition-colors shadow-md disabled:bg-gray-400"
                disabled>ì „ì†¡</button>
        </div>
    </div>

    <script>
        // Configuration from FastAPI URL path
        const pathParts = window.location.pathname.split('/');
        const reportIdIndex = pathParts.indexOf('reports') + 1;
        const reportId = parseInt(pathParts[reportIdIndex]);
        const userId = 999999;

        // States
        let chatHistory = [];
        const chatBox = document.getElementById('chat-box');
        const userInput = document.getElementById('user-input');
        const sendBtn = document.getElementById('send-btn');
        const headerInfo = document.getElementById('header-info');
        const loadingEl = document.getElementById('loading');

        // UI Utilities
        function appendMessage(role, content, messageId = null) {
            const msgDiv = document.createElement('div');
            msgDiv.className = role === 'USER' ? 'flex justify-end' : 'flex justify-start';
            if (messageId) msgDiv.id = `msg-${messageId}`;

            const bubbleDiv = document.createElement('div');
            if (role === 'USER') {
                bubbleDiv.className = 'max-w-[75%] bg-blue-600 text-white rounded-2xl p-4 shadow-sm';
                bubbleDiv.textContent = content;
            } else if (role === 'SYSTEM') {
                bubbleDiv.className = 'w-full bg-white border border-gray-200 text-gray-800 rounded-xl p-5 shadow-sm markdown-body';
                bubbleDiv.innerHTML = marked.parse(content);
            } else {
                // AI
                bubbleDiv.className = 'max-w-[85%] bg-white border border-gray-200 text-gray-800 rounded-2xl p-4 shadow-sm markdown-body';
                bubbleDiv.innerHTML = marked.parse(content);
            }

            msgDiv.appendChild(bubbleDiv);
            chatBox.appendChild(msgDiv);
            chatBox.scrollTop = chatBox.scrollHeight;
            return msgDiv;
        }

        function updateAiMessage(messageId, markdownChunk) {
            const msgDiv = document.getElementById(`msg-${messageId}`);
            if (msgDiv) {
                const bubbleDiv = msgDiv.querySelector('.markdown-body');
                bubbleDiv.innerHTML = marked.parse(markdownChunk);
                chatBox.scrollTop = chatBox.scrollHeight;
            }
        }

        // Input Control
        function setInputState(enabled) {
            userInput.disabled = !enabled;
            sendBtn.disabled = !enabled;
            if (enabled) userInput.focus();
            else {
                loadingEl.classList.remove('hidden');
            }
        }

        function hideLoading() {
            loadingEl.classList.add('hidden');
        }

        // 1. Initialize logic: Fetch weekly report
        async function initChat() {
            // ë°±ì—”ë“œê°€ ì œê³µí•´ì£¼ëŠ” ë ˆí¬íŠ¸ë¼ê³  ê°€ì • (DBì— ì €ì¥ëœ contentë¥¼ í•˜ë“œì½”ë”©)
            const reportContent = `# ğŸ“… ì£¼ê°„ ë¦¬í¬íŠ¸ (2026-01-25 ~ 2026-02-20)

ì§€ë‚œ 4ì£¼ê°„ì˜ ê¸°ë¡ì„ ë°”íƒ•ìœ¼ë¡œ ë¶„ì„í•œ ì£¼ê°„ ë ˆí¬íŠ¸ì…ë‹ˆë‹¤. ì‚¬ìš©ìë‹˜ì€ ë°”ìœ ì¼ì • ì†ì—ì„œë„ ì „ê³µ ì—­ëŸ‰ ê°•í™”ì™€ ìê¸°ê³„ë°œ ì‚¬ì´ì˜ ê· í˜•ì„ ì¡ê¸° ìœ„í•´ ê¾¸ì¤€íˆ ë…¸ë ¥í•´ ì˜¤ì…¨ìŠµë‹ˆë‹¤.

---

### 1. ì´ë²ˆ ì£¼ ìš”ì•½ (Weekly Summary)
ìµœê·¼ 1ì£¼ì¼(2/15~2/20)ì€ ì´ì „ ì£¼ë“¤ì— ë¹„í•´ **ì‹¤í–‰ë ¥ì´ ë§¤ìš° ë†’ì•˜ë˜ ì‹œê¸°**ì˜€ìŠµë‹ˆë‹¤. íŠ¹íˆ 2ì›” ì¤‘ìˆœ(2/9~2/14)ì— ë°œìƒí–ˆë˜ ì¼ë¶€ ë¯¸ì´í–‰ ê³¼ì œ(TODO)ë“¤ì„ ì´ë²ˆ ì£¼ì—ëŠ” ëŒ€ë¶€ë¶„ ì™„ë£Œ(DONE)ë¡œ ì „í™˜í•˜ë©° ë°€ë¦° ì¼ì •ë“¤ì„ ì„±ê³µì ìœ¼ë¡œ ì†Œí™”í•´ëƒˆìŠµë‹ˆë‹¤. 

ì¡¸ì—… ê³¼ì œì˜ í•µì‹¬ì¸ ë°±ì—”ë“œ ê°œë°œê³¼ ì•Œê³ ë¦¬ì¦˜ ìµœì í™”ì— ì§‘ì¤‘í•˜ë©´ì„œë„, ê¸°ìˆ  ë¸”ë¡œê·¸ ì‘ì„±ê³¼ í—¬ìŠ¤ì¥ ë°©ë¬¸ ë“± ë£¨í‹´ì„ ì§€í‚¤ë ¤ëŠ” ì˜ì§€ê°€ ë‹ë³´ì˜€ìŠµë‹ˆë‹¤. ì „ë°˜ì ìœ¼ë¡œ 'AFTERNOON'ê³¼ 'NIGHT' ì‹œê°„ëŒ€ì˜ ì§‘ì¤‘ë ¥ì„ í™œìš©í•´ ë³µì¡í•œ ê°œë°œ ì—…ë¬´ë¥¼ í•´ê²°í•˜ëŠ” ê²½í–¥ì„ ë³´ì˜€ìŠµë‹ˆë‹¤.

---

### 2. ì£¼ìš” ì„±ê³¼ ë° ì¼ì • ë¶„ì„ (Key Achievements & Schedule Analysis)

#### **ğŸš€ ì£¼ìš” ì„±ê³¼**
*   **ì¡¸ì—… ê³¼ì œ ê³ ë„í™”:** 'ì¶”ì²œ ì•Œê³ ë¦¬ì¦˜ ì„±ëŠ¥ ìµœì í™”'ì™€ 'ì¡¸ì‘ ë°±ì—”ë“œ í•µì‹¬ API ê°œë°œ'ì„ 4ì£¼ ë‚´ë‚´ ìµœìš°ì„  ìˆœìœ„ë¡œ ë‘ê³  ì§„í–‰í•˜ì…¨ìŠµë‹ˆë‹¤. íŠ¹íˆ 2ì›” 16ì¼ë¶€í„° 18ì¼ê¹Œì§€ ì§‘ì¤‘ì ì¸ ìµœì í™” ì‘ì—…ì„ í†µí•´ í”„ë¡œì íŠ¸ì˜ ì™„ì„±ë„ë¥¼ ë†’ì˜€ìŠµë‹ˆë‹¤.
*   **ê¸°ìˆ ì  ì„±ì¥ ê¸°ë¡:** ë§¤ì£¼ 'ê¸°ìˆ  ë¸”ë¡œê·¸ ì‘ì„±(ì£¼ê°„ íšŒê³ )'ì„ ìŠì§€ ì•Šê³  ìˆ˜í–‰í•˜ë©°, ë‹¨ìˆœ ê°œë°œì— ê·¸ì¹˜ì§€ ì•Šê³  ë³¸ì¸ì˜ ì§€ì‹ì„ ì •ë¦¬í•˜ëŠ” ìŠµê´€ì„ ìœ ì§€í•˜ê³  ìˆìŠµë‹ˆë‹¤.
*   **ì² ì €í•œ í…ŒìŠ¤íŠ¸ ë¬¸í™”:** 'í…ŒìŠ¤íŠ¸ ì½”ë“œ ì‘ì„± ë°©ì–´'ì™€ 'í”„ë¡ íŠ¸ì—”ë“œ API ì—°ë™ í…ŒìŠ¤íŠ¸'ë¥¼ ì¼ì •ì— ë°°ì¹˜í•˜ì—¬ ì‹œìŠ¤í…œì˜ ì•ˆì •ì„±ì„ í™•ë³´í•˜ë ¤ëŠ” ë…¸ë ¥ì´ í™•ì¸ë©ë‹ˆë‹¤.

#### **ğŸ“… ì¼ì • íŒ¨í„´ ë° ë³€ê²½ ì´ë ¥ ë¶„ì„**
*   **ìš´ë™ ì‹œê°„ì˜ ê³ ì°©í™”:** í—¬ìŠ¤ì¥(ì›¨ì´íŠ¸ íŠ¸ë ˆì´ë‹) ì¼ì •ì´ ê±°ì˜ ë§¤ë²ˆ **19:30ì—ì„œ 20:00ë¡œ ë³€ê²½(MOVE_TIME)**ë˜ëŠ” íŒ¨í„´ì´ ê´€ì°°ë©ë‹ˆë‹¤. ì´ëŠ” ì €ë… ì‹ì‚¬ í›„ íœ´ì‹ ì‹œê°„ì´ ê³„íšë³´ë‹¤ ì¡°ê¸ˆ ë” í•„ìš”í•˜ê±°ë‚˜, ì´ë™ ì‹œê°„ì— ë³€ìˆ˜ê°€ ìˆìŒì„ ì‹œì‚¬í•©ë‹ˆë‹¤.
*   **ì§‘ì¤‘ ì‹œê°„ëŒ€ í™œìš©:** ì£¼ë¡œ 'NIGHT' í˜¹ì€ 'AFTERNOON'ì— ë†’ì€ ì§‘ì¤‘ë ¥ì„ ë°œíœ˜í•˜ê³  ìˆìœ¼ë©°, ì‹¤ì œë¡œ ì–´ë ¤ìš´ ì•Œê³ ë¦¬ì¦˜ ë¬¸ì œë‚˜ ë…¼ë¬¸ ìˆ˜ì • ì‘ì—…ì´ ì´ ì‹œê°„ëŒ€ì— ì§‘ì¤‘ë˜ì–´ ìˆìŠµë‹ˆë‹¤.
*   **ìœ ì—°í•œ ìœ„ê¸° ëŒ€ì²˜:** 1ì›” 30ì¼ì˜ ê¸‰ì‘ìŠ¤ëŸ¬ìš´ ë©´ì ‘ ì œì•ˆì— ë”°ë¥¸ í¬íŠ¸í´ë¦¬ì˜¤ ìˆ˜ì •, 2ì›” 7ì¼ì˜ ì›¹ì†Œì¼“ ì„œë²„ ì—ëŸ¬ ê¸´ê¸‰ ë³µêµ¬ ë“± ì˜ˆê¸°ì¹˜ ëª»í•œ ìƒí™©ì—ì„œë„ ê¸°ì¡´ ì¼ì •ì„ ì¡°ì •í•˜ë©° ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ” ë›°ì–´ë‚œ ì ì‘ë ¥ì„ ë³´ì—¬ì£¼ì…¨ìŠµë‹ˆë‹¤.

---

### 3. ë‹¤ìŒ ì£¼ ìŠ¤ì¼€ì¤„ë§ ì¡°ì–¸ (Suggestions for Next Week)

*   **ìš´ë™ ì‹œì‘ ì‹œê°„ í˜„ì‹¤í™”:** í—¬ìŠ¤ì¥ ì¼ì •ì„ ì²˜ìŒë¶€í„° **20:00**ë¡œ ì„¤ì •í•´ ë³´ì„¸ìš”. 4ì£¼ê°„ì˜ ë°ì´í„°ê°€ ë³´ì—¬ì£¼ë“¯, 19:30ì€ ì‚¬ìš©ìë‹˜ê»˜ ë‹¤ì†Œ ì´‰ë°•í•œ ì‹œê°„ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì²˜ìŒë¶€í„° í˜„ì‹¤ì ì¸ ì‹œê°„ì„ ê³„íší•˜ë©´ 'ì¼ì • ë³€ê²½'ì— ë”°ë¥¸ ì‹¬ë¦¬ì  ë¶€ë‹´ì„ ì¤„ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
*   **ì˜¤ì „ ì‹œê°„ëŒ€ì˜ 'Warm-up' í™œìš©:** í˜„ì¬ ì˜¤ì „ 9ì‹œë¶€í„° 11ì‹œ ì‚¬ì´ì— 'ì¡¸ì‘ ë°±ì—”ë“œ ê°œë°œ'ì´ë‚˜ 'ì•Œê³ ë¦¬ì¦˜' ê°™ì€ ê³ ê°•ë„ ì—…ë¬´ê°€ ë°°ì¹˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ë§Œì•½ ì˜¤ì „ ì§‘ì¤‘ë„ê°€ ë‚®ê²Œ ëŠê»´ì§„ë‹¤ë©´, ì´ ì‹œê°„ì—ëŠ” ìƒëŒ€ì ìœ¼ë¡œ ê°€ë²¼ìš´ 'AI íŠ¸ë Œë“œ ë¦¬ì„œì¹˜'ë‚˜ 'ë©”ì¼ í™•ì¸' ë“±ì„ ë°°ì¹˜í•˜ê³  ê³ ê°•ë„ ì—…ë¬´ë¥¼ ì˜¤í›„ ì§‘ì¤‘ ì‹œê°„ëŒ€ë¡œ ì˜®ê¸°ëŠ” ì „ëµë„ ê³ ë ¤í•´ ë³´ì„¸ìš”.
*   **ì—¬ìœ  ì‹œê°„(Buffer) í™•ë³´:** 2ì›” 6ì¼ì˜ ë²ˆê°œ ëª¨ì„ì´ë‚˜ 2ì›” 7ì¼ì˜ ê¸´ê¸‰ ì„œë²„ ë³µêµ¬ ì‚¬ë¡€ì²˜ëŸ¼ ì˜ˆìƒì¹˜ ëª»í•œ ì´ë²¤íŠ¸ëŠ” ì–¸ì œë“  ë°œìƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. í•˜ë£¨ ì¤‘ 1ì‹œê°„ ì •ë„ëŠ” 'ì˜ˆë¹„ ì‹œê°„'ìœ¼ë¡œ ë¹„ì›Œë‘ì–´, ëŒë°œ ìƒí™©ì´ ë°œìƒí•´ë„ ì „ì²´ ìŠ¤ì¼€ì¤„ì´ ë’¤ë¡œ ë°€ë¦¬ì§€ ì•Šë„ë¡ ê´€ë¦¬í•´ ë³´ì‹œê¸¸ ê¶Œì¥í•©ë‹ˆë‹¤.

ì‚¬ìš©ìë‹˜ì€ ì´ë¯¸ ì¶©ë¶„íˆ í›Œë¥­í•œ ëª°ì…ë„ë¥¼ ë³´ì—¬ì£¼ê³  ê³„ì‹­ë‹ˆë‹¤. ë‹¤ìŒ ì£¼ì—ë„ ê³„íší•˜ì‹  ëª©í‘œë“¤ì„ í•˜ë‚˜ì”© ë‹¬ì„±í•´ ë‚˜ê°€ëŠ” ì¦ê±°ì›€ì„ ëˆ„ë¦¬ì‹œê¸¸ ì‘ì›í•©ë‹ˆë‹¤! ğŸŒŸ`;

            chatHistory.push({ messageId: 1, senderType: 'SYSTEM', messageType: 'TEXT', content: `[ì£¼ê°„ ë ˆí¬íŠ¸ ì»¨í…ìŠ¤íŠ¸]\n\n${reportContent}` });
            headerInfo.innerText = `Report ID: ${reportId} ê¸°ë°˜ ëŒ€í™” ì¤‘ ğŸ’¬`;
            appendMessage('SYSTEM', `ğŸ“Š **ì£¼ê°„ ë ˆí¬íŠ¸ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.**\n\n---\n${reportContent}`);

            setInputState(true);
        }

        // 2. Chat logic: Send Message to POST /respond, then listen to SSE
        async function sendMessage() {
            const text = userInput.value.trim();
            if (!text) return;

            // Add to UI and History
            userInput.value = '';
            setInputState(false);

            // messageId generation simple mock 
            const userMsgId = Date.now();
            const aiMsgId = userMsgId + 1;

            chatHistory.push({ messageId: userMsgId, senderType: 'USER', messageType: 'TEXT', content: text });
            appendMessage('USER', text);

            try {
                // STEP A: POST /respond
                const postResp = await fetch(`/ai/v2/reports/${reportId}/chat/respond`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        userId: userId,
                        messageId: aiMsgId,
                        messages: chatHistory
                    })
                });

                if (!postResp.ok) throw new Error('Failed to start chat session');

                // Generate empty bubble for AI
                const aiElem = appendMessage('AI', '...', aiMsgId);
                let fullAiContent = "";
                let sseStarted = false;

                // STEP B: GET /stream via EventSource
                const eventSource = new EventSource(`/ai/v2/reports/${reportId}/chat/respond/${aiMsgId}/stream`);

                eventSource.addEventListener('start', (e) => {
                    hideLoading();
                    sseStarted = true;
                    updateAiMessage(aiMsgId, "");
                });

                eventSource.addEventListener('chunk', (e) => {
                    const data = JSON.parse(e.data);
                    fullAiContent += data.delta;
                    updateAiMessage(aiMsgId, fullAiContent);
                });

                eventSource.addEventListener('complete', (e) => {
                    const data = JSON.parse(e.data);
                    console.log('Stream complete:', data.status);
                    eventSource.close();
                    chatHistory.push({ messageId: aiMsgId, senderType: 'AI', messageType: 'TEXT', content: fullAiContent });
                    setInputState(true);
                });

                eventSource.addEventListener('error', (e) => {
                    // Occurs when manually yielded error event or network fail
                    console.error("SSE Error:", e);
                    // If the stream wasn't properly ended, the browser tries to reconnect. We must manually close it.
                    eventSource.close();
                    let errMsg = "ìŠ¤íŠ¸ë¦¬ë° ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.";

                    // e.data might be present if we yielded an error event payload
                    if (e.data) {
                        try {
                            const parsed = JSON.parse(e.data);
                            if (parsed.message) errMsg = `ì˜¤ë¥˜: ${parsed.message}`;
                        } catch (jsonE) { }
                    }

                    fullAiContent += `\n\n> âš ï¸ **${errMsg}**`;
                    updateAiMessage(aiMsgId, fullAiContent);
                    setInputState(true);
                });

            } catch (e) {
                hideLoading();
                appendMessage('SYSTEM', `âŒ ìš”ì²­ ì‹¤íŒ¨: ${e.message}`);
                setInputState(true);
            }
        }

        sendBtn.addEventListener('click', sendMessage);
        userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') sendMessage();
        });

        // Start
        window.onload = initChat;

    </script>
</body>

</html>